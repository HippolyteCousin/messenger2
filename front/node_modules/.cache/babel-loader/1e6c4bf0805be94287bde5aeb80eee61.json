{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar createKeyRange = require('./util/key-range');\n\nvar deserialize = require('./util/deserialize');\n\nvar noop = function () {};\n\nmodule.exports = Iterator;\n\nfunction Iterator(db, location, options) {\n  AbstractIterator.call(this, db);\n  this._limit = options.limit;\n  this._count = 0;\n  this._callback = null;\n  this._cache = [];\n  this._completed = false;\n  this._aborted = false;\n  this._error = null;\n  this._transaction = null;\n  this._keys = options.keys;\n  this._values = options.values;\n  this._keyAsBuffer = options.keyAsBuffer;\n  this._valueAsBuffer = options.valueAsBuffer;\n\n  if (this._limit === 0) {\n    this._completed = true;\n    return;\n  }\n\n  try {\n    var keyRange = createKeyRange(options);\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true;\n    return;\n  }\n\n  this.createIterator(location, keyRange, options.reverse);\n}\n\ninherits(Iterator, AbstractIterator);\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  var self = this;\n  var transaction = this.db.db.transaction([location], 'readonly');\n  var store = transaction.objectStore(location);\n  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next');\n\n  req.onsuccess = function (ev) {\n    var cursor = ev.target.result;\n    if (cursor) self.onItem(cursor);\n  };\n\n  this._transaction = transaction; // If an error occurs (on the request), the transaction will abort.\n\n  transaction.onabort = function () {\n    self.onAbort(self._transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    self.onComplete();\n  };\n};\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value);\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor.continue();\n  }\n\n  this.maybeNext();\n};\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true;\n  this._error = err;\n  this.maybeNext();\n};\n\nIterator.prototype.onComplete = function () {\n  this._completed = true;\n  this.maybeNext();\n};\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback);\n\n    this._callback = null;\n  }\n};\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    var err = this._error;\n    this._error = null;\n\n    this._nextTick(callback, err);\n  } else if (this._cache.length > 0) {\n    var key = this._cache.shift();\n\n    var value = this._cache.shift();\n\n    if (this._keys && key !== undefined) {\n      key = this._deserializeKey(key, this._keyAsBuffer);\n    } else {\n      key = undefined;\n    }\n\n    if (this._values && value !== undefined) {\n      value = this._deserializeValue(value, this._valueAsBuffer);\n    } else {\n      value = undefined;\n    }\n\n    this._nextTick(callback, null, key, value);\n  } else if (this._completed) {\n    this._nextTick(callback);\n  } else {\n    this._callback = callback;\n  }\n}; // Exposed for the v4 to v5 upgrade utility\n\n\nIterator.prototype._deserializeKey = deserialize;\nIterator.prototype._deserializeValue = deserialize;\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    return this._nextTick(callback, this._error);\n  } // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n\n\n  this.onItem = noop;\n  this.onAbort = callback;\n  this.onComplete = callback;\n};","map":{"version":3,"sources":["/home/duck/Documents/tweb/messenger2/frontend/node_modules/level-js/iterator.js"],"names":["inherits","require","AbstractIterator","createKeyRange","deserialize","noop","module","exports","Iterator","db","location","options","call","_limit","limit","_count","_callback","_cache","_completed","_aborted","_error","_transaction","_keys","keys","_values","values","_keyAsBuffer","keyAsBuffer","_valueAsBuffer","valueAsBuffer","keyRange","e","createIterator","reverse","prototype","self","transaction","store","objectStore","req","openCursor","onsuccess","ev","cursor","target","result","onItem","onabort","onAbort","error","Error","oncomplete","onComplete","push","key","value","continue","maybeNext","err","_next","callback","_nextTick","length","shift","undefined","_deserializeKey","_deserializeValue","_end"],"mappings":"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","sourcesContent":["'use strict'\n\nvar inherits = require('inherits')\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator\nvar createKeyRange = require('./util/key-range')\nvar deserialize = require('./util/deserialize')\nvar noop = function () {}\n\nmodule.exports = Iterator\n\nfunction Iterator (db, location, options) {\n  AbstractIterator.call(this, db)\n\n  this._limit = options.limit\n  this._count = 0\n  this._callback = null\n  this._cache = []\n  this._completed = false\n  this._aborted = false\n  this._error = null\n  this._transaction = null\n\n  this._keys = options.keys\n  this._values = options.values\n  this._keyAsBuffer = options.keyAsBuffer\n  this._valueAsBuffer = options.valueAsBuffer\n\n  if (this._limit === 0) {\n    this._completed = true\n    return\n  }\n\n  try {\n    var keyRange = createKeyRange(options)\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true\n    return\n  }\n\n  this.createIterator(location, keyRange, options.reverse)\n}\n\ninherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  var self = this\n  var transaction = this.db.db.transaction([location], 'readonly')\n  var store = transaction.objectStore(location)\n  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next')\n\n  req.onsuccess = function (ev) {\n    var cursor = ev.target.result\n    if (cursor) self.onItem(cursor)\n  }\n\n  this._transaction = transaction\n\n  // If an error occurs (on the request), the transaction will abort.\n  transaction.onabort = function () {\n    self.onAbort(self._transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    self.onComplete()\n  }\n}\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value)\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor.continue()\n  }\n\n  this.maybeNext()\n}\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true\n  this._error = err\n  this.maybeNext()\n}\n\nIterator.prototype.onComplete = function () {\n  this._completed = true\n  this.maybeNext()\n}\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback)\n    this._callback = null\n  }\n}\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    var err = this._error\n    this._error = null\n    this._nextTick(callback, err)\n  } else if (this._cache.length > 0) {\n    var key = this._cache.shift()\n    var value = this._cache.shift()\n\n    if (this._keys && key !== undefined) {\n      key = this._deserializeKey(key, this._keyAsBuffer)\n    } else {\n      key = undefined\n    }\n\n    if (this._values && value !== undefined) {\n      value = this._deserializeValue(value, this._valueAsBuffer)\n    } else {\n      value = undefined\n    }\n\n    this._nextTick(callback, null, key, value)\n  } else if (this._completed) {\n    this._nextTick(callback)\n  } else {\n    this._callback = callback\n  }\n}\n\n// Exposed for the v4 to v5 upgrade utility\nIterator.prototype._deserializeKey = deserialize\nIterator.prototype._deserializeValue = deserialize\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    return this._nextTick(callback, this._error)\n  }\n\n  // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n  this.onItem = noop\n  this.onAbort = callback\n  this.onComplete = callback\n}\n"]},"metadata":{},"sourceType":"script"}